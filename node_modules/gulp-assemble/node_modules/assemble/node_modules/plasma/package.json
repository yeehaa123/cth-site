{
  "name": "plasma",
  "version": "0.2.7",
  "description": "Build a context object to pass to templates. Plasma can load data from a flexible range of configuration and file formats, including JSON/YAML data files defined with minimatch/glob patterns.",
  "repository": {
    "type": "git",
    "url": "https://github.com/jonschlinkert/plasma.git"
  },
  "bugs": {
    "url": "https://github.com/jonschlinkert/plasma/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/jonschlinkert/plasma/blob/master/LICENSE-MIT"
    }
  ],
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "dependencies": {
    "expand-hash": "~0.2.0",
    "expander": "~0.3.3",
    "frep": "~0.2.0",
    "fs-utils": "~0.4.0",
    "lodash": "~2.4.1",
    "verbalize": "~0.1.2"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "fs-utils": "~0.4.0",
    "mocha": "~1.17.0",
    "node-bar": "~0.1.1",
    "node-baz": "~0.1.0",
    "node-foo": "~0.1.3",
    "verb": "~0.2.1"
  },
  "keywords": [
    "config",
    "data",
    "expand",
    "glob",
    "json",
    "load",
    "read data",
    "yaml",
    "yml"
  ],
  "readme": "# plasma [![NPM version](https://badge.fury.io/js/plasma.png)](http://badge.fury.io/js/plasma)\n\n> Build a context object to pass to templates. Plasma can load data from a flexible range of configuration and file formats, including JSON/YAML data files defined with minimatch/glob patterns.\n\nPlasma makes it easy to load data. Here are some examples:\n\n```js\nvar config = [\n  // load data to the root object\n  ['components/*.json'],\n  // load data to the `pkg` object\n  {name: 'pkg', src: 'package.json'},\n  // load data to the `site` object\n  {name: 'site', src: '.assemblerc.yml'},\n  // load data to an object named after the basename of each file\n  // e.g. foo.json is loaded to `{foo: {// data}}`\n  {name: ':basename', src: ['data/*.{json,yml}']},\n  // Load data from src to `{a: {b: {c: {// data}}}`\n  {dothash: true, name: 'a.b.c', src: ['*.json']}\n];\n\n// Load in config data.\nvar data = plasma.load(config);\n```\n## Install\n\nInstall with [npm](npmjs.org):\n\n```bash\nnpm i plasma --save\n```\n\n\n## What problem is Plasma solving?\n#### problem\n\nLet's say you need to load data for templates.\n\nIf you want to read JSON files, you might do something like this:\n\n```js\nvar fs = require('fs');\nvar data = JSON.parse(fs.readFileSync('my-data-file.json', 'utf8'));\n```\nOr this:\n\n```js\nvar data = require('./my-data-file.json')\n```\n\nWhat about YAML? Maybe you'd do something like this:\n\n```js\nvar fs = require('fs');\nvar YAML = require('js-yaml');\nvar data = YAML.load(fs.readFileSync('my-data-file.yml', 'utf8'));\n```\n\nWhat if you want to use glob patterns to get all the data files in a directory?\n\n```js\nvar glob = require('globule');\nglob.find('*.{json,yml}').map(function(filepath) {\n  // do something to read files\n});\n```\n\nNot too bad, but now you need to do some logic to merge the data from the files as their loaded. And what if you want to also define data in the config, and have that merged with the data from the files you're loading? e.g\n\n```js\nvar config = {\n  a: {\n    b: \"foo\"\n  }\n};\n_.extend(config, data); // merge file data with config data\n```\n\nIf you've ever done this before, you know that it gets much more complicated. This is where Plasma can help.\n\n#### solution\n\nOr, you can make life easy, and just do:\n\n```js\nvar plasma = require('plasma');\nplasma.load('*.{json,yml}');\n```\n\nNeed config data merged in? Do this:\n\n```js\nplasma.load('*.{json,yml}', {foo: 'bar', baz: 'quux'});\n// or this\nplasma.load(['*.{json,yml}', 'something.json'], {foo: 'bar', baz: 'quux'});\n```\n\nWant the data from certain files to be _namespaced_? (e.g. data from `foo.json` gets loaded to an object named `foo`), do this:\n\n```js\nplasma.load({name: 'foo', src: ['*.{json,yml}', 'something.json']});\n```\n\nPlasma does a lot more, [jump to the examples](#examples)\n\n\n## Methods\n### plasma.normalize()\n\nReturns an array of objects with basic heuristics that can be referenced later by the `load()` function. Glob patterns are also expanded during normalization. For example, either of these:\n\n```js\nplasma.normalize('*.json')\n// or\nplasma.normalize(['*.json'])\n```\nwill be normalized to:\n\n```js\n[{__normalized__: true, src: ['bower.json', 'package.json']}]\n```\nOf if an object is passed, like:\n\n```js\n{name: 'foo', src: ['*.json'], z: 'x'}\n```\nIt will be normalized to:\n\n```js\n[{__normalized__: true, name: 'foo', src: ['bower.json', 'package.json'], z: 'x'}]\n```\n\nThis is really a private method, but it's exposed to help with debugging and in case you need to modify how the data is normalized before it's loaded.\n\n\n### plasma.load()\n\nReturns an object with three properties, `{ orig: {}, data: {}, nomatch: [] }`:\n\n* `orig`: a clone of the original data passed to `plasma.load()`\n* `data`: the loaded config object to be passed to templates. e.g. `plasma.load('*.json').data`\n* `nomatch`: an array of properties that could not be normalized to an object or matched to a filepath. this is useful for debugging\n\n\n## Examples\nYou may pass a string, object or array to either `plasma.normalize()` or `plasma.load()` using any of the following conventions (see [the examples](./docs/examples.js)):\n\n```js\n// Strings\n'a'; // pushed to `nomatch`\n'*.json'; // if files exist, their paths will be expanded and added to a `src` array\n\n// Arrays\n['a', 'b', 'c']; // pushed to `nomatch`\n['*.json', 'a', 'b', 'c']; // *.json is pushed to `src`, the rest is pushed to `nomatch`\n['*.json', {src: ['c/*.json']}];\n['*.json', {src: ['*.json'], cwd: 'c'}];\n['*.json', {src: ['*.json'], cwd: 'c', prefixBase: true }];\n['*.json', {src: ['*.json'], cwd: 'c', prefixBase: true }];\n['*.json', {src: ['*.json'], cwd: 'c', expand: false }];\n['*.json', {src: ['c/*.json'], expand: false }];\n['*.json', '*.yml', {src: ['c/*.json']}];\n['*.json', '*.yml', {src: ['c/*.json'], name: 'f'}];\n['*.json', '*.yml', {src: ['c/*.json'], name: 'f', expand: false }];\n\n// Objects\n{a: 'b', b: 'c', d: 'd'};\n\n// Object with src\n{src: 'c/*.json' };\n{src: ['c/*.json'] };\n{src: ['c/*.json', 'd/*.json'] };\n{src: ['c/*.json'], b: 'c' };\n{src: ['c/*.json'], b: 'c', {d: 'e'} };\n{src: ['c/*.json'], b: 'c' };\n{src: ['c/*.json'], b: 'c', expand: false };\n\n// Named objects\n{name: 'a', b: 'c' };\n{name: 'a', b: 'c', {d: 'e'} };\n{name: 'a', b: 'c', {d: 'e', name: 'f'} };\n{name: 'a', b: 'c', {d: 'e', name: 'f', src: ['*.json']} };\n{name: 'a', b: 'c', {d: 'e'}, f: ['g', 'h', 'i'] };\n{name: 'a', src: 'c/*.json' };\n{name: 'a', src: '*.json', cwd: 'c' };\n{name: 'a', src: '*.json', cwd: 'c', prefixBase: true };\n{name: 'a', src: ['c/*.json'] };\n{name: 'a', src: ['c/*.json'], b: 'c' };\n{name: 'a', src: ['c/*.json', 'd/*.json'], b: 'c' };\n{name: 'a', src: ['c/*.json'] };\n{name: 'a', src: ['c/*.json'], expand: false };\n\n// Array of objects\n[{a: 'b', b: 'c', d: 'd'}];\n[{a: 'b', b: 'c'}, {d: 'd'}];\n[{a: 'b', b: 'c'}, {src: '*.json'}];\n[{a: 'b', b: 'c'}, {src: '*.json', name: 'f'}];\n[{a: 'b', b: 'c'}, {src: '*.json', name: 'f', expand: false }];\n[{a: 'b', b: 'c'}, {src: '*.json', name: 'f'}];\n\n['*.json', {src: '*.json'}, '*.yml', src: ['*.json', '**/*.yml']},, name: 'a', src: ['*.json'], b: 'c'} ];\n\n// Prop strings\n{name: ':basename', a: 'b' };\n{name: ':basename' };\n{name: ':basename', src: 'a/b/c/*.json' };\n{name: ':dirname', src: 'a/b/c/*.json' };\n\n\n// dot hashes\n{name: 'a', c: 'd' };\n{name: 'a', c: { d: 'e'} };\n{name: 'a.b', c: 'd' };\n{name: 'a.b', c: { d: 'e'} };\n{name: 'a.b.c', c: { d: 'e'} };\n\n{name: 'a', {c: ['d', 'e']} };\n{name: 'a.b', {c: ['d', 'e']} };\n{name: 'a.b.c', {c: ['d', 'e']} };\n\n{name: 'a', src: 'a/b/c/*.json' };\n{name: 'a.b', src: 'a/b/c/*.json' };\n{name: 'a.b.c', src: 'a/b/c/*.json' };\n\n{name: 'a', src: ['a/b/c/*.json'] };\n{name: 'a.b', src: ['a/b/c/*.json'] };\n{name: 'a.b.c', src: ['a/b/c/*.json'] };\n\n{name: 'a', {'b': 'c'} };\n{name: 'a', {'b.c': 'd'} };\n{name: 'a', {'b.c.d': 'e'} };\n\n// Prop strings with dot hashes\n{name: ':dirname.:basename', src: ['i18n/*.json'] };\n{name: ':basename' };\n{name: ':basename', src: 'a/b/c/*.json' };\n{name: ':dirname', src: 'a/b/c/*.json' };\n```\n\n### Invalid patterns\nNeither of these can be normalized to a useful object:\n\n```js\nvar foo = 'a';\nvar foo = ['a', 'b', 'c'];\n```\n\nThese, and any other patterns that can't be normalized are pushed to a `nomatch` array.\n\n## Tests\nRun `mocha`\n\n## Author\n\n**Jon Schlinkert**\n\n+ [github/jonschlinkert](https://github.com/jonschlinkert)\n+ [twitter/jonschlinkert](http://twitter.com/jonschlinkert)\n\n## License\nCopyright (c) 2014 undefined, contributors.  \nReleased under the MIT license\n\n***\n\n_This file was generated by [verb-cli](https://github.com/assemble/verb-cli) on April 13, 2014._",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/jonschlinkert/plasma",
  "_id": "plasma@0.2.7",
  "_from": "plasma@^0.2.7"
}
